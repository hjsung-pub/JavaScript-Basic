<!DOCTYPE html>
<html>
<head>
    <title>Document</title>
</head>
<body>
    <script>
        let x =  0.1 + 0.2;
        console.log(x); //출력값 : 0.30000000000000004 >> 무한 소수인 경우 64비트를 넘어가면 근사치로 반올림하여 반환해줌, 원하는 값을 얻지 못할 수 있다.
        //Number는 64비트 부동소수점으로 저장됨
        console.log(1/2); //유한소수
        console.log(2/3); //무한소수

        //0.1 = 1/10
        //0.2 = 1/5
        console.log((0.1).toString(2)); //문자타입으로 변환, 2진수로 표현
        //출력값 : 0.0001100110011001100110011001100110011001100110011001101
        //맨 앞 1비트 - 양수면 0, 음수면 1
        //그 다음 11비트 - 지수부 > 2^(n-1) - n + m >> 2^(11-1) - 1 - 4(오른쪽으로 이동하면 -, 왼쪽으로 +1을 만나기까지 이동하는 횟수) = 1019 
        //그 다음 52비트 - 가수부

        console.log((1019).toString(2));
        //출력값 : 1111111011 >> 10자리 출력, 지수부는 11자리기 때문에 맨앞 0을 붙이기 >> 01111111011
        //이런식으로 64비트로 0.1과 0.2를 변환해서 두 값을 더하고 다시 10진수로 변환을 하게 되면 0.30000000000000004 이 값이 나오게된다.

        //연산이 들어가는 코드를 작성할때 BigNumber.js, Big.js, Decimal.js 라이브러리 사용 추천

        let x2 = 999999999999999; //정상출력
        let x3 = 9999999999999999; //출력값 : 10000000000000000

        console.log(x2);
        console.log(x3);
        console.log(Number.MAX_SAFE_INTEGER); //출력값 : 9007199254740991 >> 자바스크립트 Number객체에서 제공하는 안정적인 integer 최대값이며, 이 값을 넘어가게 되면 값이 이상해질 수 있다.

    </script>
</body>
</html>